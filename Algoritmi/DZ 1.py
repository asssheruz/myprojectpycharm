//Реализовать алгоритм пирамидальной сортировки (HeapSort)
//#region Немного теории
/* Время О(n*logn) для сотировки n объектов (как и для сортировки слиянием)
 * Дополнительная память O(1) (вместо О(n) для сортировки слиянием)
 * Обладает преимуществом 2-х алгоритмов сортировки: время от слиянием, память от вставками
 *
 * Массив для сортировки:
 * индекс   1  2  3  4  5  6  7  8  9 10
 * элемент 16 14 10 08 07 09 03 02 04 01
 *
 * Структура даных, которую использует алгоритм - двоичная куча (или бинарное/двоичное дерево)
 *                               i = 1
 *                              a[i]=16
 *                 |                              |
 *               i = 2                          i = 3
 *              a[i]=14                        a[i]=10
 *         |               |               |            |
 *       i = 4           i = 5           i = 6        i = 7
 *      a[i]=8           a[i]=7         a[i]=1        a[i]=3
 *     |      |         |
 *  i = 8    i = 9    i =10
 * a[i]=2   a[i]=4   a[i]=1
 *
 * Двоичная куча (binary heap) - массив с определёнными свойствами упорядоченности (как двочное дерево).
 * Каждая вершина дерева соответсвует элементу массива. Если вершина имеет индекс i,
 * то её родитель (уровень выше) имеет индекс [i/2] (вершина с индексом 1 является корнем),
 * а её дети (уровень ниже) - индексы 2i и 2i+1.
 * Допущение. Куча может не занимать всего массива и поэтому
 * будем хранить не только массив А и его длину length[A], но также специальный параметр
 * heap-size[A] (размер кучи): heap-size[A] <= length[A].
 * Куча состоит из элементов A[1], ..., A[heap-size[A]].
 *
 * Основное свойство кучи: для каждой вершине i, кроме корня
 *      A[PARENT(i)] >= A[i]
 * т.е. значение потомка не привосходит значения предка. Таким образом, наибольший элемент дерева
 * (или любого поддерева) находится в корневой вершине дерева (этого поддерева)
 *
 * Движение по куче осуществляется процедурами
 * PARENT(i)
 *      return [i/2]
 * LEFT(i)
 *      return [2*i]
 * RIGHT(i)
 *      return [2*i+1]
 *
 * Основные операции над кучей
 *  Метод Heapify позволяет  поддекрживать основное свойство кучи
 *      Время работы составляет О(logn)
 * Метод BuildHeap строит кучу из исходного (неотсортированного) массива
 *      Время работы О(n)
 * Метод HeapSort сортирует массив, не используя дополнительной памяти
 *      Время работы О(n*logn)
 *
 * Литература Кормен Т. и др. - Алгоритмы: Построение и анализ
 *
 * !!! ПРИМЕЧАНИЕ. В литературе индексация массива с "1", реализация кода ниже с "0"
 *
 */
//#endregion

package Seminars.Sem_01;

public class task_HeapSort {
    // Поля - вместо конструктора сразу присваиваю пустое значение
    private static int myLength = 1;
    private static int[] myArray = new int[myLength];
    private static int heapSize = myLength-1; // размер кучи (-1, т.к. обработка с нуля)
    // Основной метод - вызов выполнения программы
    public static void main(String[] args) {
        myLength = 10;     // 0   1   2  3  4  5  6  7  8  9
        myArray = new int[] {16, 14, 10, 8, 7, 9, 3, 2, 4, 1};
        printArray("исходный");
        heapSort();
        printArray("отсортированный");
    }
    // Методы работы с индексами массива
    public static int getParentIndex(int i){    return (i-1) / 2;    }
    public static int getLeftIndex(int i)  {    return 2 * i + 1;    }
    public static int getRightIndex(int i) {    return 2 * i + 2;}
    // Формирование упорядоченной кучи
    public static void heapify(int index)
    {
        // поиск вершины с максимальным элементом
        int lsIndex = getLeftIndex(index);  // т.к. нумерация с 0
        int rsIndex = getRightIndex(index); // т.к. нумерация с 0

        // Поиск наибольшего из двух непосредсвенных потомков (листьев)
        int largestIndex = index;// допускаем: максимальное ветки в корне. Так ли?
        if (lsIndex <= heapSize) // левый лист, если существует
            if (myArray[lsIndex] > myArray[index])
                largestIndex = lsIndex;
        if (rsIndex <= heapSize) // правый лист, если существует
            if(myArray[rsIndex] > myArray[largestIndex])
                largestIndex = rsIndex;

        // переставляем максимальное значение в вершину данной ветки
        // на уровень выше путём обмена, одно из если дочерних листьев больше
        // index = largestIndex - это условие выхода из метода
        // (максимум в нужном месте - родительской позиции данной ветки), иначе снова:
        if (index != largestIndex){
            // обмен - наибольший с низкого на верхний уровень, меньшее значение с корня в ветку
            swap(index, largestIndex);
            // рекурсивный вызов
            // при посторении - по направлению от самой нижней крайней правой ведки до корня дерева
            // при сортировки - по направлению от корня к нижней ветке и обратно до получения максимального в корне
            heapify(largestIndex);
        }
    }
    // Формирование/постоение/исправление из массива кучи/пирамиды
    public static void heapBuild(){
        heapSize = myLength-1;
        // обходим массив с середины к первому элементу
        // т.е. по левой части, правая вся состоит из листьев
        // левая же часть смешанная (корни+листья)
        for (int i = myLength/2-1; i >= 0; --i)
            heapify(i);
    }
    // Сортировка с помощью кучи
    public static void heapSort(){
        heapBuild();                 // первоначальное исправление кучи с обходом с самой нижней ветки
        for (int i = myLength-1; i >= 1; --i){
            // переставляем максимальное из корня в конец на позицию i
            // в корень же значение по одному c конца при пошаговом движении в начало на каждой итерации
            swap(0, i);
            heapSize = heapSize - 1; // уменьшаем размер просматриваемой кучи, т.к. максимальный перекинут в правую часть кучи
            heapify(0);       // опять начинаем исправление кучи по свойству возрастания (с корня движемся вниз),
                                     // так как в корень было записано не максимальный элемент (с конца переставили)
            String strOut = " - итерация " + (myLength - i) + " -> ";
            printArray(strOut);
        }
    }
    // Метод перестановки значений массива, элемент с правым индексом в левый
    public static void swap(int lsIndex, int rsIndex){
        int temp = myArray[lsIndex];    // переставляем максимальное из корня в конец на позицию i
        myArray[lsIndex] = myArray[rsIndex]; // в корень же значение с по одному конца при пошаговом движении в начало на каждой итерации
        myArray[rsIndex] = temp;
    }
    // Печать массива
    public static void printArray(String someStr){
        StringBuffer strBuffer = new StringBuffer("Массив " + someStr + " = [");
        for(int j = 0; j < myLength-1; ++j){
            strBuffer.append(" " + myArray[j] + ",");
        }
        strBuffer.append(" " + myArray[myLength-1] + " ]");
        System.out.println(strBuffer);
    }
}